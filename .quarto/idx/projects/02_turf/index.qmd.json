{"title":"<u>Fast TURF with RCPP</u>","markdown":{"yaml":{"title":"<u>Fast TURF with RCPP</u>","description":"Optimized a TURF model by rewriting it in C++ using Rcpp, achieving major speed-ups compared to base R.","image":"images/turf-thumbnail.png"},"headingText":"What is TURF?","containsRefs":false,"markdown":"\n\n\nTURF (Total Unduplicated Reach and Frequency) is a marketing analytics technique used to identify the optimal combination of items (e.g., products, features, messages) that maximizes audience reach. It helps businesses decide which subset of options can collectively appeal to the largest number of unique customers.\n\n## Previous Approach at GBK\n\nThey were using R code with lots of loops to calculate all possible combinations for TURF analysis. While this approach works for small datasets, it becomes very slow and inefficient when there are many products or respondents.\n\nWhy? \nBecause, R loops are not the fastest — they go one step at a time.\n\nTURF needs to test millions of combinations, especially when selecting the best 5 out of 20+ items.\n\nAs the number of items grows, the number of combinations explodes, making the R code much slower.\n\nThis made it hard to work with larger datasets or run multiple TURF analyses quickly.\n\n\n\n## My Solution\n### The C++ Code:###\n\nI rewrote the critical portions in C++ using `Rcpp` to drastically reduce computation time and memory usage.\n```{cpp}\n#include <Rcpp.h>\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nDataFrame turf_m(NumericMatrix mat, int m, int keep = 10, SEXP w = R_NilValue) {\n  int N = mat.nrow(), J = mat.ncol();\n  if (m < 1 || m > J) stop(\"m must be between 1 and ncol(mat)\");\n  \n  // Handle weights\n  NumericVector weights = (Rf_isNull(w) || (Rf_length(w) == 1 && as<double>(w) == 1.0))\n    ? NumericVector(N, 1.0)\n      : as<NumericVector>(w);\n  \n  if (weights.size() != N || is_true(any(weights < 0)) || sum(weights) == 0 ||\n      is_true(any(!is_finite(weights))) || is_true(any(is_na(weights))))\n    stop(\"Invalid weights\");\n  \n  // Generate combinations of m columns\n  IntegerMatrix combos = transpose(as<IntegerMatrix>(Function(\"combn\")(J, m)));\n  int M = combos.nrow();\n  \n  NumericVector reach(M), freq(M);\n  for (int i = 0; i < M; ++i) {\n    NumericVector y(N);\n    for (int j = 0; j < m; ++j) {\n      int col = combos(i, j) - 1;\n      for (int n = 0; n < N; ++n)\n        y[n] += mat(n, col);\n    }\n    \n    double rsum = 0, fsum = 0, wsum = sum(weights);\n    for (int n = 0; n < N; ++n) {\n      if (y[n] > 0) rsum += weights[n];\n      fsum += y[n] * weights[n];\n    }\n    \n    reach[i] = rsum / wsum;\n    freq[i]  = fsum / wsum;\n  }\n  \n  // Sort by reach and keep top combos\n  IntegerVector ord = as<IntegerVector>(Function(\"order\")(reach, _[\"decreasing\"] = true));\n  int n = std::min(M, keep);\n  ord = ord[Range(0, n - 1)];\n  \n  // Build output\n  List out = List::create(\n    _[\"size\"] = rep(m, n),\n    _[\"rank\"] = seq_len(n),\n    _[\"reach\"] = reach[ord - 1],\n                      _[\"freq\"]  = freq[ord - 1]\n  );\n  \n  for (int j = 0; j < m; ++j) {\n    IntegerVector items(n);\n    for (int i = 0; i < n; ++i)\n      items[i] = combos(ord[i] - 1, j);\n    out[\"item\" + std::to_string(j + 1)] = items;\n  }\n  \n  return as<DataFrame>(out);\n}\n\n// [[Rcpp::export]]\nDataFrame turf(NumericMatrix mat, int j = -1, int keep = 10, SEXP w = R_NilValue) {\n  if (j == -1) j = std::min(5, mat.ncol() - 1);\n  \n  List res;\n  for (int m = 1; m <= j; ++m)\n    res.push_back(turf_m(mat, m, keep, w));\n  \n  return as<DataFrame>(Function(\"rbindlist\", Environment::namespace_env(\"data.table\"))(res, Named(\"fill\") = true));\n}\n\n```\n\nLet me show you how much faster it is:\n\n```{r}\nlibrary(Rcpp)\nlibrary(microbenchmark)\n\n# Compile the C++ function\nsourceCpp(\"turf_rcpp.cpp\")\n\n# Load sample data\ndata <- as.matrix(read.csv(\"out_mat1_forSB.csv\"))\n\n# Run TURF using optimized function\nresult <- turf(data, j = 5, keep = 10)\nprint(result)\n\n# Benchmark performance\nsystem.time(result_og <- turf(data))\n\nmicrobenchmark(\n  turf(data, j = 5, keep = 10),\n  times = 10\n)\n```\n\n\n\n","srcMarkdownNoYaml":"\n\n## What is TURF?\n\nTURF (Total Unduplicated Reach and Frequency) is a marketing analytics technique used to identify the optimal combination of items (e.g., products, features, messages) that maximizes audience reach. It helps businesses decide which subset of options can collectively appeal to the largest number of unique customers.\n\n## Previous Approach at GBK\n\nThey were using R code with lots of loops to calculate all possible combinations for TURF analysis. While this approach works for small datasets, it becomes very slow and inefficient when there are many products or respondents.\n\nWhy? \nBecause, R loops are not the fastest — they go one step at a time.\n\nTURF needs to test millions of combinations, especially when selecting the best 5 out of 20+ items.\n\nAs the number of items grows, the number of combinations explodes, making the R code much slower.\n\nThis made it hard to work with larger datasets or run multiple TURF analyses quickly.\n\n\n\n## My Solution\n### The C++ Code:###\n\nI rewrote the critical portions in C++ using `Rcpp` to drastically reduce computation time and memory usage.\n```{cpp}\n#include <Rcpp.h>\nusing namespace Rcpp;\n\n// [[Rcpp::export]]\nDataFrame turf_m(NumericMatrix mat, int m, int keep = 10, SEXP w = R_NilValue) {\n  int N = mat.nrow(), J = mat.ncol();\n  if (m < 1 || m > J) stop(\"m must be between 1 and ncol(mat)\");\n  \n  // Handle weights\n  NumericVector weights = (Rf_isNull(w) || (Rf_length(w) == 1 && as<double>(w) == 1.0))\n    ? NumericVector(N, 1.0)\n      : as<NumericVector>(w);\n  \n  if (weights.size() != N || is_true(any(weights < 0)) || sum(weights) == 0 ||\n      is_true(any(!is_finite(weights))) || is_true(any(is_na(weights))))\n    stop(\"Invalid weights\");\n  \n  // Generate combinations of m columns\n  IntegerMatrix combos = transpose(as<IntegerMatrix>(Function(\"combn\")(J, m)));\n  int M = combos.nrow();\n  \n  NumericVector reach(M), freq(M);\n  for (int i = 0; i < M; ++i) {\n    NumericVector y(N);\n    for (int j = 0; j < m; ++j) {\n      int col = combos(i, j) - 1;\n      for (int n = 0; n < N; ++n)\n        y[n] += mat(n, col);\n    }\n    \n    double rsum = 0, fsum = 0, wsum = sum(weights);\n    for (int n = 0; n < N; ++n) {\n      if (y[n] > 0) rsum += weights[n];\n      fsum += y[n] * weights[n];\n    }\n    \n    reach[i] = rsum / wsum;\n    freq[i]  = fsum / wsum;\n  }\n  \n  // Sort by reach and keep top combos\n  IntegerVector ord = as<IntegerVector>(Function(\"order\")(reach, _[\"decreasing\"] = true));\n  int n = std::min(M, keep);\n  ord = ord[Range(0, n - 1)];\n  \n  // Build output\n  List out = List::create(\n    _[\"size\"] = rep(m, n),\n    _[\"rank\"] = seq_len(n),\n    _[\"reach\"] = reach[ord - 1],\n                      _[\"freq\"]  = freq[ord - 1]\n  );\n  \n  for (int j = 0; j < m; ++j) {\n    IntegerVector items(n);\n    for (int i = 0; i < n; ++i)\n      items[i] = combos(ord[i] - 1, j);\n    out[\"item\" + std::to_string(j + 1)] = items;\n  }\n  \n  return as<DataFrame>(out);\n}\n\n// [[Rcpp::export]]\nDataFrame turf(NumericMatrix mat, int j = -1, int keep = 10, SEXP w = R_NilValue) {\n  if (j == -1) j = std::min(5, mat.ncol() - 1);\n  \n  List res;\n  for (int m = 1; m <= j; ++m)\n    res.push_back(turf_m(mat, m, keep, w));\n  \n  return as<DataFrame>(Function(\"rbindlist\", Environment::namespace_env(\"data.table\"))(res, Named(\"fill\") = true));\n}\n\n```\n\nLet me show you how much faster it is:\n\n```{r}\nlibrary(Rcpp)\nlibrary(microbenchmark)\n\n# Compile the C++ function\nsourceCpp(\"turf_rcpp.cpp\")\n\n# Load sample data\ndata <- as.matrix(read.csv(\"out_mat1_forSB.csv\"))\n\n# Run TURF using optimized function\nresult <- turf(data, j = 5, keep = 10)\nprint(result)\n\n# Benchmark performance\nsystem.time(result_og <- turf(data))\n\nmicrobenchmark(\n  turf(data, j = 5, keep = 10),\n  times = 10\n)\n```\n\n\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":false,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["../../custom.scss"],"toc":true,"include-in-header":["../../meta.html"],"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.32","google-site-verification":"NsbAdXXXyyhbPUML-RAXRhkbgt8stoPOTp47ISXGzQk","editor":"visual","theme":"cosmo","title":"<u>Fast TURF with RCPP</u>","description":"Optimized a TURF model by rewriting it in C++ using Rcpp, achieving major speed-ups compared to base R.","image":"images/turf-thumbnail.png"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}